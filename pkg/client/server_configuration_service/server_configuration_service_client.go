// Code generated by go-swagger; DO NOT EDIT.

package server_configuration_service

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new server configuration service API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for server configuration service API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	GetCategoryDetails(params *GetCategoryDetailsParams, opts ...ClientOption) (*GetCategoryDetailsOK, error)

	GetO11nTypes(params *GetO11nTypesParams, opts ...ClientOption) (*GetO11nTypesOK, error)

	GetPluginAPI(params *GetPluginAPIParams, opts ...ClientOption) (*GetPluginAPIOK, error)

	GetScriptingAPI(params *GetScriptingAPIParams, opts ...ClientOption) (*GetScriptingAPIOK, error)

	GetServerConfiguration(params *GetServerConfigurationParams, opts ...ClientOption) (*GetServerConfigurationOK, error)

	GetSettings(params *GetSettingsParams, opts ...ClientOption) (*GetSettingsOK, error)

	ImportServerConfiguration(params *ImportServerConfigurationParams, opts ...ClientOption) (*ImportServerConfigurationOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
GetCategoryDetails gets scripting API for actions grouped by categories

Returns supported Orchestrator scripting API for actions grouped by categories.
*/
func (a *Client) GetCategoryDetails(params *GetCategoryDetailsParams, opts ...ClientOption) (*GetCategoryDetailsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCategoryDetailsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getCategoryDetails",
		Method:             "GET",
		PathPattern:        "/server-configuration/api/category/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCategoryDetailsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetCategoryDetailsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getCategoryDetails: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetO11nTypes gets supported types

Returns supported Orchestrator types.
*/
func (a *Client) GetO11nTypes(params *GetO11nTypesParams, opts ...ClientOption) (*GetO11nTypesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetO11nTypesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getO11nTypes",
		Method:             "GET",
		PathPattern:        "/server-configuration/types",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetO11nTypesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetO11nTypesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getO11nTypes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPluginAPI gets scripting API for a plugin

Returns supported Orchestrator scripting API for a plugin.
*/
func (a *Client) GetPluginAPI(params *GetPluginAPIParams, opts ...ClientOption) (*GetPluginAPIOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPluginAPIParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getPluginApi",
		Method:             "GET",
		PathPattern:        "/server-configuration/api/plugins/{plugin}/{version}/{build}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPluginAPIReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPluginAPIOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPluginApi: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetScriptingAPI gets scripting API

Returns supported Orchestrator scripting API.
*/
func (a *Client) GetScriptingAPI(params *GetScriptingAPIParams, opts ...ClientOption) (*GetScriptingAPIOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScriptingAPIParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getScriptingApi",
		Method:             "GET",
		PathPattern:        "/server-configuration/api",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScriptingAPIReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetScriptingAPIOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getScriptingApi: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetServerConfiguration gets server configuration

Returns a human-readable representation of the Orchestrator server configuration.
*/
func (a *Client) GetServerConfiguration(params *GetServerConfigurationParams, opts ...ClientOption) (*GetServerConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetServerConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getServerConfiguration",
		Method:             "GET",
		PathPattern:        "/server-configuration",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetServerConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetServerConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getServerConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetSettings gets subset of the server configuration settings
*/
func (a *Client) GetSettings(params *GetSettingsParams, opts ...ClientOption) (*GetSettingsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSettingsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getSettings",
		Method:             "GET",
		PathPattern:        "/server-configuration/settings",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSettingsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSettingsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSettings: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportServerConfiguration imports server configuration

Imports/exports the server configuration. The exported file is available as an attachment with MIME type application/zip. To perform an export request, an empty file must be attached to the request. Otherwise, the server tries to import a configuration.<br /><br />The format of the exported or imported file is same as that of files exported or imported by using the Orchestrator configuration interface. The configuration binary content must be available as multi-part content (see RFC-2387 for details). Details of working with multi-part resources depend on the used client HTTP/REST library. For example, in Spring it will look like:<br /><pre>Sample client code that imports a server configuration:<br /> -----------------------<br />MultiValueMap<String, Object> parts = new LinkedMultiValueMap<String, Object>();<br />parts.add("file", new FileSystemResource("/path/to/vco_config_file.zip"))<br />;parts.add("password", "secret")<br />;parts.add("importIdentity", Boolean.FALSE);<br /><br />getRestTemplate().postForEntity("https://localhost:8281/vco/api/server-configuration", parts, Void.class);<br />-----------------------</pre>
*/
func (a *Client) ImportServerConfiguration(params *ImportServerConfigurationParams, opts ...ClientOption) (*ImportServerConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportServerConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importServerConfiguration",
		Method:             "POST",
		PathPattern:        "/server-configuration",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportServerConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportServerConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importServerConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
