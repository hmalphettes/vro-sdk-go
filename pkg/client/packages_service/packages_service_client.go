// Code generated by go-swagger; DO NOT EDIT.

package packages_service

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new packages service API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for packages service API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	AddActionToPackage(params *AddActionToPackageParams, opts ...ClientOption) (*AddActionToPackageNoContent, error)

	AddActionsToPackage(params *AddActionsToPackageParams, opts ...ClientOption) (*AddActionsToPackageNoContent, error)

	AddConfigurationElementCategoryToPackage(params *AddConfigurationElementCategoryToPackageParams, opts ...ClientOption) (*AddConfigurationElementCategoryToPackageNoContent, error)

	AddConfigurationElementToPackage(params *AddConfigurationElementToPackageParams, opts ...ClientOption) (*AddConfigurationElementToPackageNoContent, error)

	AddRecourceCategoryToPackage(params *AddRecourceCategoryToPackageParams, opts ...ClientOption) (*AddRecourceCategoryToPackageNoContent, error)

	AddRecourceElementToPackage(params *AddRecourceElementToPackageParams, opts ...ClientOption) (*AddRecourceElementToPackageNoContent, error)

	AddWorkflowCategoryToPackage(params *AddWorkflowCategoryToPackageParams, opts ...ClientOption) (*AddWorkflowCategoryToPackageNoContent, error)

	AddWorkflowToPackage(params *AddWorkflowToPackageParams, opts ...ClientOption) (*AddWorkflowToPackageNoContent, error)

	CreatePackage(params *CreatePackageParams, opts ...ClientOption) (*CreatePackageCreated, error)

	DeleteActionElement(params *DeleteActionElementParams, opts ...ClientOption) (*DeleteActionElementNoContent, error)

	DeleteConfigurationElement(params *DeleteConfigurationElementParams, opts ...ClientOption) (*DeleteConfigurationElementNoContent, error)

	DeletePackage(params *DeletePackageParams, opts ...ClientOption) (*DeletePackageNoContent, error)

	DeletePackagePermissionRule(params *DeletePackagePermissionRuleParams, opts ...ClientOption) (*DeletePackagePermissionRuleNoContent, error)

	DeletePermissionsForPackage(params *DeletePermissionsForPackageParams, opts ...ClientOption) (*DeletePermissionsForPackageNoContent, error)

	DeleteResourceElement(params *DeleteResourceElementParams, opts ...ClientOption) (*DeleteResourceElementNoContent, error)

	DeleteWorkflowElement(params *DeleteWorkflowElementParams, opts ...ClientOption) (*DeleteWorkflowElementNoContent, error)

	GetImportPackageDetails(params *GetImportPackageDetailsParams, opts ...ClientOption) (*GetImportPackageDetailsOK, error)

	GetPackagePermissionRule(params *GetPackagePermissionRuleParams, opts ...ClientOption) (*GetPackagePermissionRuleOK, error)

	GetPermissionsForPackage(params *GetPermissionsForPackageParams, opts ...ClientOption) (*GetPermissionsForPackageOK, error)

	ImportPackage(params *ImportPackageParams, opts ...ClientOption) (*ImportPackageCreated, error)

	ImportPackageExtended(params *ImportPackageExtendedParams, opts ...ClientOption) (*ImportPackageExtendedCreated, error)

	InsertPermissionsForPackage(params *InsertPermissionsForPackageParams, opts ...ClientOption) (*InsertPermissionsForPackageOK, *InsertPermissionsForPackageCreated, error)

	ListAllPackages(params *ListAllPackagesParams, opts ...ClientOption) (*ListAllPackagesOK, error)

	PackageDetails(params *PackageDetailsParams, opts ...ClientOption) (*PackageDetailsOK, error)

	RebuildPackage(params *RebuildPackageParams, opts ...ClientOption) (*RebuildPackageAccepted, error)

	UpdatePackage(params *UpdatePackageParams, opts ...ClientOption) (*UpdatePackageNoContent, error)

	UpdatePackagePermissionRule(params *UpdatePackagePermissionRuleParams, opts ...ClientOption) (*UpdatePackagePermissionRuleNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AddActionToPackage adds action to package

Add action and its dependencies to package
*/
func (a *Client) AddActionToPackage(params *AddActionToPackageParams, opts ...ClientOption) (*AddActionToPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddActionToPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addActionToPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/action/{categoryName}/{actionName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddActionToPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddActionToPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addActionToPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddActionsToPackage adds actions to package

Add all actions and its dependencies from given category to package
*/
func (a *Client) AddActionsToPackage(params *AddActionsToPackageParams, opts ...ClientOption) (*AddActionsToPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddActionsToPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addActionsToPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/action/{categoryName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddActionsToPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddActionsToPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addActionsToPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddConfigurationElementCategoryToPackage adds configuration category to package

Recursive add configuration category resources to package
*/
func (a *Client) AddConfigurationElementCategoryToPackage(params *AddConfigurationElementCategoryToPackageParams, opts ...ClientOption) (*AddConfigurationElementCategoryToPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddConfigurationElementCategoryToPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addConfigurationElementCategoryToPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/configuration_category/{configurationCategoryName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddConfigurationElementCategoryToPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddConfigurationElementCategoryToPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addConfigurationElementCategoryToPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddConfigurationElementToPackage adds configuration element to package

Add configuration element and its dependencies to package
*/
func (a *Client) AddConfigurationElementToPackage(params *AddConfigurationElementToPackageParams, opts ...ClientOption) (*AddConfigurationElementToPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddConfigurationElementToPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addConfigurationElementToPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/configuration/{configurationId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddConfigurationElementToPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddConfigurationElementToPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addConfigurationElementToPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddRecourceCategoryToPackage adds recource category to package

Add all resource elements from resource category and its children to package
*/
func (a *Client) AddRecourceCategoryToPackage(params *AddRecourceCategoryToPackageParams, opts ...ClientOption) (*AddRecourceCategoryToPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddRecourceCategoryToPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addRecourceCategoryToPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/resource_category/{categoryName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddRecourceCategoryToPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddRecourceCategoryToPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addRecourceCategoryToPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddRecourceElementToPackage adds recource element to package

Add resource element and its dependencies to package
*/
func (a *Client) AddRecourceElementToPackage(params *AddRecourceElementToPackageParams, opts ...ClientOption) (*AddRecourceElementToPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddRecourceElementToPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addRecourceElementToPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/resource/{resourceId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddRecourceElementToPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddRecourceElementToPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addRecourceElementToPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddWorkflowCategoryToPackage adds workflow category to package

Add all workflows from given category and its subcategories to package
*/
func (a *Client) AddWorkflowCategoryToPackage(params *AddWorkflowCategoryToPackageParams, opts ...ClientOption) (*AddWorkflowCategoryToPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddWorkflowCategoryToPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addWorkflowCategoryToPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/workflow_category/{categoryId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddWorkflowCategoryToPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddWorkflowCategoryToPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addWorkflowCategoryToPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AddWorkflowToPackage adds workflow to package

Add workflow and its dependencies to package
*/
func (a *Client) AddWorkflowToPackage(params *AddWorkflowToPackageParams, opts ...ClientOption) (*AddWorkflowToPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddWorkflowToPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addWorkflowToPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/workflow/{workflowId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddWorkflowToPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddWorkflowToPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addWorkflowToPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreatePackage creates new package

Create new package.
*/
func (a *Client) CreatePackage(params *CreatePackageParams, opts ...ClientOption) (*CreatePackageCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createPackage",
		Method:             "PUT",
		PathPattern:        "/packages/{packageName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreatePackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreatePackageCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteActionElement deletes action element

Delete action element
*/
func (a *Client) DeleteActionElement(params *DeleteActionElementParams, opts ...ClientOption) (*DeleteActionElementNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteActionElementParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteActionElement",
		Method:             "DELETE",
		PathPattern:        "/packages/{packageName}/action/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteActionElementReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteActionElementNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteActionElement: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteConfigurationElement deletes configuration element

Delete configuration element
*/
func (a *Client) DeleteConfigurationElement(params *DeleteConfigurationElementParams, opts ...ClientOption) (*DeleteConfigurationElementNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConfigurationElementParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteConfigurationElement",
		Method:             "DELETE",
		PathPattern:        "/packages/{packageName}/configuration/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConfigurationElementReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteConfigurationElementNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteConfigurationElement: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeletePackage deletes package

<p>Deletes a package with a given name.</p><p>Takes 3 options for deleting a package:</p><ul><li>deletePackage - deletes the package without the content</li><li>deletePackageWithContent - deletes the package along with the content. If other packages share elements with this package, they will be deleted</li><li>deletePackageKeepingShared - deletes the package along with the content. If other packages share elements with this package, the elements will not be removed.</li></ul><p>If no option parameter is provided, the default one is used: deletePackage</p>
*/
func (a *Client) DeletePackage(params *DeletePackageParams, opts ...ClientOption) (*DeletePackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deletePackage",
		Method:             "DELETE",
		PathPattern:        "/packages/{packageName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeletePackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeletePackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deletePackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeletePackagePermissionRule deletes permission rule
*/
func (a *Client) DeletePackagePermissionRule(params *DeletePackagePermissionRuleParams, opts ...ClientOption) (*DeletePackagePermissionRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePackagePermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deletePackagePermissionRule",
		Method:             "DELETE",
		PathPattern:        "/packages/{packageName}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeletePackagePermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeletePackagePermissionRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deletePackagePermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeletePermissionsForPackage deletes all permissions

Deletes all permissions for a package with a given name.
*/
func (a *Client) DeletePermissionsForPackage(params *DeletePermissionsForPackageParams, opts ...ClientOption) (*DeletePermissionsForPackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePermissionsForPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deletePermissionsForPackage",
		Method:             "DELETE",
		PathPattern:        "/packages/{packageName}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeletePermissionsForPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeletePermissionsForPackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deletePermissionsForPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteResourceElement deletes resource element

Delete resource element
*/
func (a *Client) DeleteResourceElement(params *DeleteResourceElementParams, opts ...ClientOption) (*DeleteResourceElementNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteResourceElementParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteResourceElement",
		Method:             "DELETE",
		PathPattern:        "/packages/{packageName}/resource/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteResourceElementReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteResourceElementNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteResourceElement: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteWorkflowElement deletes workflow element

Delete workflow element
*/
func (a *Client) DeleteWorkflowElement(params *DeleteWorkflowElementParams, opts ...ClientOption) (*DeleteWorkflowElementNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteWorkflowElementParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteWorkflowElement",
		Method:             "DELETE",
		PathPattern:        "/packages/{packageName}/workflow/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteWorkflowElementReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteWorkflowElementNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteWorkflowElement: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetImportPackageDetails analyses uploaded package file and returns details about package elements and certificate

Analyses uploaded package file and returns details about package elements and certificate. The package binary content should be available as multi-part content (see RFC-2387 for details). Details of working with multi-part resources depend on the used client's HTTP/REST library. For example, in Spring it will look like:<br /><pre>Sample client code:<br />-------------------<br />String url = "https://localhost:8281/vco/api/packages/";<br />MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();<br />Resource r = new FileSystemResource("D:/path/to/some.package");<br />parts.put("file", Arrays.asList(r));<br />new RestTemplate().postForLocation(url, parts);<br />------------------- </pre>
*/
func (a *Client) GetImportPackageDetails(params *GetImportPackageDetailsParams, opts ...ClientOption) (*GetImportPackageDetailsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetImportPackageDetailsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getImportPackageDetails",
		Method:             "POST",
		PathPattern:        "/packages/import-details",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetImportPackageDetailsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetImportPackageDetailsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getImportPackageDetails: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPackagePermissionRule gets permission rule

Retrieves details for a specific permission rule. Each rule contains information about the principal and he access rights assigned.
*/
func (a *Client) GetPackagePermissionRule(params *GetPackagePermissionRuleParams, opts ...ClientOption) (*GetPackagePermissionRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPackagePermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getPackagePermissionRule",
		Method:             "GET",
		PathPattern:        "/packages/{packageName}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPackagePermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPackagePermissionRuleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPackagePermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPermissionsForPackage gets package permissions

Retrieves package permissions.
*/
func (a *Client) GetPermissionsForPackage(params *GetPermissionsForPackageParams, opts ...ClientOption) (*GetPermissionsForPackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPermissionsForPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getPermissionsForPackage",
		Method:             "GET",
		PathPattern:        "/packages/{packageName}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPermissionsForPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPermissionsForPackageOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPermissionsForPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportPackage imports package

Imports a package. The package binary content should be available as multi-part content (see RFC-2387 for details). Details of working with multi-part resources depend on the used client's HTTP/REST library. For example, in Spring it will look like:<br /><pre>Sample client code:<br />-------------------<br />String url = "https://localhost:8281/vco/api/packages/";<br />MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();<br />Resource r = new FileSystemResource("D:/path/to/some.package");<br />parts.put("file", Arrays.asList(r));<br />new RestTemplate().postForLocation(url, parts);<br />------------------- </pre>
*/
func (a *Client) ImportPackage(params *ImportPackageParams, opts ...ClientOption) (*ImportPackageCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importPackage",
		Method:             "POST",
		PathPattern:        "/packages",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportPackageCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportPackageExtended imports package based on a import specification

Imports a package based on a import specification. The package binary content should be available as multi-part content (see RFC-2387 for details). Details of working with multi-part resources depend on the used client's HTTP/REST library. For example, in Spring it will look like:<br /><pre>Sample client code:<br />-------------------<br />String url = "https://localhost:8281/vco/api/packages/";<br />MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();<br />Resource r = new FileSystemResource("D:/path/to/some.package");<br />parts.put("file", Arrays.asList(r));<br />new RestTemplate().postForLocation(url, parts);<br />------------------- </pre>
*/
func (a *Client) ImportPackageExtended(params *ImportPackageExtendedParams, opts ...ClientOption) (*ImportPackageExtendedCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportPackageExtendedParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importPackageExtended",
		Method:             "POST",
		PathPattern:        "/packages/extendedImport",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportPackageExtendedReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportPackageExtendedCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importPackageExtended: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
InsertPermissionsForPackage sets permissions for package

Set permissions for package with given name.
*/
func (a *Client) InsertPermissionsForPackage(params *InsertPermissionsForPackageParams, opts ...ClientOption) (*InsertPermissionsForPackageOK, *InsertPermissionsForPackageCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInsertPermissionsForPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "insertPermissionsForPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InsertPermissionsForPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *InsertPermissionsForPackageOK:
		return value, nil, nil
	case *InsertPermissionsForPackageCreated:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for packages_service: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListAllPackages lists all packages

Returns a list of all deployed packages.
*/
func (a *Client) ListAllPackages(params *ListAllPackagesParams, opts ...ClientOption) (*ListAllPackagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAllPackagesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listAllPackages",
		Method:             "GET",
		PathPattern:        "/packages",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListAllPackagesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListAllPackagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listAllPackages: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PackageDetails packages details

Returns details of the package, with list all contained workflows and actions.
*/
func (a *Client) PackageDetails(params *PackageDetailsParams, opts ...ClientOption) (*PackageDetailsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPackageDetailsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "packageDetails",
		Method:             "GET",
		PathPattern:        "/packages/{packageName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PackageDetailsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PackageDetailsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for packageDetails: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RebuildPackage rebuilds package

Rebuild package.
*/
func (a *Client) RebuildPackage(params *RebuildPackageParams, opts ...ClientOption) (*RebuildPackageAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRebuildPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "rebuildPackage",
		Method:             "POST",
		PathPattern:        "/packages/{packageName}/rebuild",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RebuildPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RebuildPackageAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for rebuildPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdatePackage updates package

Update package.
*/
func (a *Client) UpdatePackage(params *UpdatePackageParams, opts ...ClientOption) (*UpdatePackageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updatePackage",
		Method:             "PATCH",
		PathPattern:        "/packages/{packageName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdatePackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdatePackageNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updatePackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdatePackagePermissionRule updates permission rule

Updates principal or access rights for single permission rule with given ID.
*/
func (a *Client) UpdatePackagePermissionRule(params *UpdatePackagePermissionRuleParams, opts ...ClientOption) (*UpdatePackagePermissionRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePackagePermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updatePackagePermissionRule",
		Method:             "PUT",
		PathPattern:        "/packages/{packageName}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdatePackagePermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdatePackagePermissionRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updatePackagePermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
