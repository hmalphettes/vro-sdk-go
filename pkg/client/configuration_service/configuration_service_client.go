// Code generated by go-swagger; DO NOT EDIT.

package configuration_service

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new configuration service API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for configuration service API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DeleteConfiguration(params *DeleteConfigurationParams, opts ...ClientOption) (*DeleteConfigurationNoContent, error)

	DeleteConfigurationPermissionRule(params *DeleteConfigurationPermissionRuleParams, opts ...ClientOption) (*DeleteConfigurationPermissionRuleNoContent, error)

	DeletePermissionsForConfiguration(params *DeletePermissionsForConfigurationParams, opts ...ClientOption) (*DeletePermissionsForConfigurationNoContent, error)

	ExportConfiguration(params *ExportConfigurationParams, opts ...ClientOption) (*ExportConfigurationOK, error)

	GetConfigurationPermissionRule(params *GetConfigurationPermissionRuleParams, opts ...ClientOption) (*GetConfigurationPermissionRuleOK, error)

	GetPermissionsForConfiguration(params *GetPermissionsForConfigurationParams, opts ...ClientOption) (*GetPermissionsForConfigurationOK, error)

	ImportConfiguration(params *ImportConfigurationParams, opts ...ClientOption) (*ImportConfigurationAccepted, error)

	InsertPermissionsForConfiguration(params *InsertPermissionsForConfigurationParams, opts ...ClientOption) (*InsertPermissionsForConfigurationOK, *InsertPermissionsForConfigurationCreated, error)

	ListAllConfigurations(params *ListAllConfigurationsParams, opts ...ClientOption) (*ListAllConfigurationsOK, error)

	UpdateConfiguration(params *UpdateConfigurationParams, opts ...ClientOption) (*UpdateConfigurationNoContent, error)

	UpdateConfigurationPermissionRule(params *UpdateConfigurationPermissionRuleParams, opts ...ClientOption) (*UpdateConfigurationPermissionRuleNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
DeleteConfiguration deletes configuration

Deletes a configuration with a given ID. If the configuration is referenced by some workflow, it is considered to be 'in use' and the delete operation will fail, unless the 'force' option is provided.
*/
func (a *Client) DeleteConfiguration(params *DeleteConfigurationParams, opts ...ClientOption) (*DeleteConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteConfiguration",
		Method:             "DELETE",
		PathPattern:        "/configurations/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteConfigurationPermissionRule deletes permission rule

Deletes a single permission rule with a given ID.
*/
func (a *Client) DeleteConfigurationPermissionRule(params *DeleteConfigurationPermissionRuleParams, opts ...ClientOption) (*DeleteConfigurationPermissionRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConfigurationPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteConfigurationPermissionRule",
		Method:             "DELETE",
		PathPattern:        "/configurations/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConfigurationPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteConfigurationPermissionRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteConfigurationPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeletePermissionsForConfiguration deletes configuration permissions

Deletes all permissions for configuration with a given ID.
*/
func (a *Client) DeletePermissionsForConfiguration(params *DeletePermissionsForConfigurationParams, opts ...ClientOption) (*DeletePermissionsForConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePermissionsForConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deletePermissionsForConfiguration",
		Method:             "DELETE",
		PathPattern:        "/configurations/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeletePermissionsForConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeletePermissionsForConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deletePermissionsForConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ExportConfiguration exports configuration

Exports a configuration by its ID. If the request is successful, the configuration binary content is available in the body of the response message. It is up to the client application to properly fetch and process this attachment, for example, by saving it to the local file system. The exported configuration has the same internal format as the configurations exported by using the Orchestrator client.
*/
func (a *Client) ExportConfiguration(params *ExportConfigurationParams, opts ...ClientOption) (*ExportConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "exportConfiguration",
		Method:             "GET",
		PathPattern:        "/configurations/{id}",
		ProducesMediaTypes: []string{"application/vcoobject+xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for exportConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetConfigurationPermissionRule gets permission rule

Retrieves details for a specific permission rule.
*/
func (a *Client) GetConfigurationPermissionRule(params *GetConfigurationPermissionRuleParams, opts ...ClientOption) (*GetConfigurationPermissionRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConfigurationPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getConfigurationPermissionRule",
		Method:             "GET",
		PathPattern:        "/configurations/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConfigurationPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetConfigurationPermissionRuleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getConfigurationPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPermissionsForConfiguration gets configuration permissions

Retrieves configuration permissions.
*/
func (a *Client) GetPermissionsForConfiguration(params *GetPermissionsForConfigurationParams, opts ...ClientOption) (*GetPermissionsForConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPermissionsForConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getPermissionsForConfiguration",
		Method:             "GET",
		PathPattern:        "/configurations/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPermissionsForConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPermissionsForConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPermissionsForConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportConfiguration imports configuration

Imports configuration in a given category. The configuration binary content should be available as multi-part content (see RFC-2387 for details). Details of working with multi-part resources depend on the used client's HTTP/REST library. For example, in Spring it will look like:<br /><pre>Sample client code:<br />-------------------<br />String url = "https://localhost:8281/vco/api/configurations/";<br />MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();<br />Resource r = new FileSystemResource("D:/path/to/some.vsoconf");<br />parts.put("file", Arrays.asList(r));<br />parts.put("categoryId", "828080808080808080808080808080807F818080013217004819830adebdb10ea");<br />new RestTemplate().postForLocation(url, parts);<br />-------------------<br /></pre>
*/
func (a *Client) ImportConfiguration(params *ImportConfigurationParams, opts ...ClientOption) (*ImportConfigurationAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importConfiguration",
		Method:             "POST",
		PathPattern:        "/configurations",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportConfigurationAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
InsertPermissionsForConfiguration inserts configuration permissions

Sets permissions for a configuration with given ID. Access rights : 'r' - VIEW,  'x' - EXECUTE, 'i' - INSPECT,  'c' - EDIT, 'a' - ADMIN
*/
func (a *Client) InsertPermissionsForConfiguration(params *InsertPermissionsForConfigurationParams, opts ...ClientOption) (*InsertPermissionsForConfigurationOK, *InsertPermissionsForConfigurationCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInsertPermissionsForConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "insertPermissionsForConfiguration",
		Method:             "POST",
		PathPattern:        "/configurations/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InsertPermissionsForConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *InsertPermissionsForConfigurationOK:
		return value, nil, nil
	case *InsertPermissionsForConfigurationCreated:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for configuration_service: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListAllConfigurations lists all configurations

Retrieves a list of all configurations.
*/
func (a *Client) ListAllConfigurations(params *ListAllConfigurationsParams, opts ...ClientOption) (*ListAllConfigurationsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAllConfigurationsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listAllConfigurations",
		Method:             "GET",
		PathPattern:        "/configurations",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListAllConfigurationsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListAllConfigurationsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listAllConfigurations: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateConfiguration updates configuration

Update ? configuration.
*/
func (a *Client) UpdateConfiguration(params *UpdateConfigurationParams, opts ...ClientOption) (*UpdateConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateConfiguration",
		Method:             "PUT",
		PathPattern:        "/configurations/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateConfigurationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateConfigurationPermissionRule updates permission rule

Updates principal or access rights for a single permission rule with a given ID.
*/
func (a *Client) UpdateConfigurationPermissionRule(params *UpdateConfigurationPermissionRuleParams, opts ...ClientOption) (*UpdateConfigurationPermissionRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateConfigurationPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateConfigurationPermissionRule",
		Method:             "PUT",
		PathPattern:        "/configurations/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateConfigurationPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateConfigurationPermissionRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateConfigurationPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
