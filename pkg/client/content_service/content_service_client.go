// Code generated by go-swagger; DO NOT EDIT.

package content_service

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new content service API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for content service API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DeleteActionByName(params *DeleteActionByNameParams, opts ...ClientOption) (*DeleteActionByNameOK, error)

	DeleteContent(params *DeleteContentParams, opts ...ClientOption) (*DeleteContentOK, error)

	DeleteContentPackage(params *DeleteContentPackageParams, opts ...ClientOption) (*DeleteContentPackageOK, error)

	ExportContentAction(params *ExportContentActionParams, opts ...ClientOption) (*ExportContentActionOK, error)

	ExportPackage(params *ExportPackageParams, opts ...ClientOption) (*ExportPackageOK, error)

	ExportWorkflow(params *ExportWorkflowParams, opts ...ClientOption) (*ExportWorkflowOK, error)

	ImportContentAction(params *ImportContentActionParams, opts ...ClientOption) (*ImportContentActionOK, error)

	ImportContentPackage(params *ImportContentPackageParams, opts ...ClientOption) (*ImportContentPackageAccepted, error)

	ImportContentWorkflow(params *ImportContentWorkflowParams, opts ...ClientOption) (*ImportContentWorkflowOK, error)

	ListActions(params *ListActionsParams, opts ...ClientOption) (*ListActionsOK, error)

	ListAllContentPackages(params *ListAllContentPackagesParams, opts ...ClientOption) (*ListAllContentPackagesOK, error)

	ListContentTypes(params *ListContentTypesParams, opts ...ClientOption) (*ListContentTypesOK, error)

	ListWorkflows(params *ListWorkflowsParams, opts ...ClientOption) (*ListWorkflowsOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
DeleteActionByName deletes action

Deletes an action with a given fully qualified name. If the action is referenced by some workflows, it is considered to be 'in use' and the delete operation will fail, unless the 'force' option is provided.
*/
func (a *Client) DeleteActionByName(params *DeleteActionByNameParams, opts ...ClientOption) (*DeleteActionByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteActionByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteActionByName",
		Method:             "DELETE",
		PathPattern:        "/content/actions/{actionName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteActionByNameReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteActionByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteActionByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteContent deletes content

Deletes a content with a given workflow ID. If the workflow is referenced by some other workflows, or is running, it is considered to be 'in use' and the delete operation will fail, unless the 'force' option is provided.
*/
func (a *Client) DeleteContent(params *DeleteContentParams, opts ...ClientOption) (*DeleteContentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteContentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteContent",
		Method:             "DELETE",
		PathPattern:        "/content/workflows/{workflowId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteContentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteContentOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteContent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteContentPackage deletes package

Deletes a package with a given name. If a package has some content (workflows, actions or other elements put inside it), it is considered to be 'in use' and the delete operation will fail, unless the 'force' option is provided.
*/
func (a *Client) DeleteContentPackage(params *DeleteContentPackageParams, opts ...ClientOption) (*DeleteContentPackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteContentPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteContentPackage",
		Method:             "DELETE",
		PathPattern:        "/content/packages/{packageName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteContentPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteContentPackageOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteContentPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ExportContentAction exports action

Export an action by its fully qualified name (category name + action name). If the request is successful, the action binary content is available as attachment with MIME type application/zip (that is, a normal ZIP file) with a default file name {actionname}.action. It is up to the client application to properly fetch and process this attachment, for example by saving it to the local file system. The exported action has the same internal format as the actions exported by using the Orchestrator client.
*/
func (a *Client) ExportContentAction(params *ExportContentActionParams, opts ...ClientOption) (*ExportContentActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportContentActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "exportContentAction",
		Method:             "GET",
		PathPattern:        "/content/actions/{actionName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportContentActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportContentActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for exportContentAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ExportPackage exports package

Exports a package by its name. If the request is successful, the package binary content is available as an attachment with MIME type application/zip (that is, a normal ZIP file) with a default file name {packagename}.package. It is up to the client application to properly fetch and process this attachment, for example by saving it to the local file system. The exported package has the same internal format as the packages exported by using the Orchestrator client
*/
func (a *Client) ExportPackage(params *ExportPackageParams, opts ...ClientOption) (*ExportPackageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "exportPackage",
		Method:             "GET",
		PathPattern:        "/content/packages/{packageName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportPackageOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for exportPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ExportWorkflow exports workflow

Exports a package by its ID. If the request is successful, the package binary content is available as an attachment with MIME type application/zip (that is, a normal ZIP file) with a default file name {workflowname}.workflow. It is up to the client application to properly fetch and process this attachment, for example by saving it to the local file system. The exported package has the same internal format as the workflows exported by using the Orchestrator client.
*/
func (a *Client) ExportWorkflow(params *ExportWorkflowParams, opts ...ClientOption) (*ExportWorkflowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "exportWorkflow",
		Method:             "GET",
		PathPattern:        "/content/workflows/{workflowId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportWorkflowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for exportWorkflow: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportContentAction imports action

Imports an action in a given category. The action binary content should be available as multi-part content (see RFC-2387 for details). Details of working with multi-part resources depend on the used client's HTTP/REST library. For example, in Spring it will look like:<br /><pre>Sample client code:<br />-------------------<br />String url = "https://localhost:8281/vco/api/content/packages/";<br />MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();<br />Resource r = new FileSystemResource("D:/path/to/some.action");<br />parts.put("file", Arrays.asList(r));<br />new RestTemplate().postForLocation(url, parts);<br />-------------------</pre>
*/
func (a *Client) ImportContentAction(params *ImportContentActionParams, opts ...ClientOption) (*ImportContentActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportContentActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importContentAction",
		Method:             "POST",
		PathPattern:        "/content/actions/{categoryName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportContentActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportContentActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importContentAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportContentPackage imports package

Imports a package. The package binary content should be available as multi-part content (see RFC-2387 for details). Details of working with multi-part resources depend on the used client's HTTP/REST library. For example, in Spring it will look like:<br /><pre>Sample client code:<br />-------------------<br />String url = "https://localhost:8281/vco/api/content/packages/";<br />MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();<br />Resource r = new FileSystemResource("D:/path/to/some.package");<br />parts.put("file", Arrays.asList(r));<br />new RestTemplate().postForLocation(url, parts);<br />-------------------</pre>
*/
func (a *Client) ImportContentPackage(params *ImportContentPackageParams, opts ...ClientOption) (*ImportContentPackageAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportContentPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importContentPackage",
		Method:             "POST",
		PathPattern:        "/content/packages",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportContentPackageReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportContentPackageAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importContentPackage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportContentWorkflow imports workflow

Imports a workflow in a given category. The workflow binary content should be available as multi-part content (see RFC-2387 for details). Details of working with multi-part resources depend on the used client's HTTP/REST library. For example, in Spring it will look like: <br /><pre>Sample client code:<br />-------------------<br />String url = "https://localhost:8281/vco/api/content/packages/";<br />MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();<br />Resource r = new FileSystemResource("D:/path/to/some.workflow");<br />parts.put("file", Arrays.asList(r));<br />new RestTemplate().postForLocation(url, parts);<br />-------------------</pre>
*/
func (a *Client) ImportContentWorkflow(params *ImportContentWorkflowParams, opts ...ClientOption) (*ImportContentWorkflowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportContentWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importContentWorkflow",
		Method:             "POST",
		PathPattern:        "/content/workflows/{categoryId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportContentWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportContentWorkflowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importContentWorkflow: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListActions lists actions

Returns a list of all deployed actions.
*/
func (a *Client) ListActions(params *ListActionsParams, opts ...ClientOption) (*ListActionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListActionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listActions",
		Method:             "GET",
		PathPattern:        "/content/actions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListActionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListActionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listActions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListAllContentPackages lists all packages

Returns a list of all deployed packages.
*/
func (a *Client) ListAllContentPackages(params *ListAllContentPackagesParams, opts ...ClientOption) (*ListAllContentPackagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAllContentPackagesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listAllContentPackages",
		Method:             "GET",
		PathPattern:        "/content/packages",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListAllContentPackagesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListAllContentPackagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listAllContentPackages: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListContentTypes lists content types

Returns links to entity type that can be exported, imported, or deleted from the Orchestrator database content. Currently, only packages, workflows, and actions are supported. Other Orchestrator objects, for example resources, can be imported or exported by wrapping them inside a package.
*/
func (a *Client) ListContentTypes(params *ListContentTypesParams, opts ...ClientOption) (*ListContentTypesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListContentTypesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listContentTypes",
		Method:             "GET",
		PathPattern:        "/content",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListContentTypesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListContentTypesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listContentTypes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListWorkflows lists workflows

Returns a list of all deployed workflows.
*/
func (a *Client) ListWorkflows(params *ListWorkflowsParams, opts ...ClientOption) (*ListWorkflowsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListWorkflowsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listWorkflows",
		Method:             "GET",
		PathPattern:        "/content/workflows",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListWorkflowsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListWorkflowsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listWorkflows: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
