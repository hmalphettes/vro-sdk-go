// Code generated by go-swagger; DO NOT EDIT.

package actions_service

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new actions service API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for actions service API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DeleteAction(params *DeleteActionParams, opts ...ClientOption) (*DeleteActionOK, error)

	DeleteActionPermissionRule(params *DeleteActionPermissionRuleParams, opts ...ClientOption) (*DeleteActionPermissionRuleNoContent, error)

	DeletePermissionsForAction(params *DeletePermissionsForActionParams, opts ...ClientOption) (*DeletePermissionsForActionNoContent, error)

	ExecuteActionByID(params *ExecuteActionByIDParams, opts ...ClientOption) (*ExecuteActionByIDOK, error)

	ExecuteActionByName(params *ExecuteActionByNameParams, opts ...ClientOption) (*ExecuteActionByNameOK, error)

	ExportAction(params *ExportActionParams, opts ...ClientOption) (*ExportActionOK, error)

	GetAction(params *GetActionParams, opts ...ClientOption) (*GetActionOK, error)

	GetActionPermissionRule(params *GetActionPermissionRuleParams, opts ...ClientOption) (*GetActionPermissionRuleOK, error)

	GetPermissionsForAction(params *GetPermissionsForActionParams, opts ...ClientOption) (*GetPermissionsForActionOK, error)

	ImportAction(params *ImportActionParams, opts ...ClientOption) (*ImportActionAccepted, error)

	InsertPermissionsForAction(params *InsertPermissionsForActionParams, opts ...ClientOption) (*InsertPermissionsForActionOK, *InsertPermissionsForActionCreated, *InsertPermissionsForActionNoContent, error)

	ListAllActions(params *ListAllActionsParams, opts ...ClientOption) (*ListAllActionsOK, error)

	UpdateActionPermissionRule(params *UpdateActionPermissionRuleParams, opts ...ClientOption) (*UpdateActionPermissionRuleNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
DeleteAction deletes an action

<p>Deletes an action with a given id.</p><p>If the action is referenced by some workflows, it is considered to be 'in use'and the delete operation will fail, unless the 'force' option is provided.</p>
*/
func (a *Client) DeleteAction(params *DeleteActionParams, opts ...ClientOption) (*DeleteActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteAction",
		Method:             "DELETE",
		PathPattern:        "/actions/{actionId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteActionPermissionRule deletes a single permission rule with a given id

Deletes a single permission rule with a given id
*/
func (a *Client) DeleteActionPermissionRule(params *DeleteActionPermissionRuleParams, opts ...ClientOption) (*DeleteActionPermissionRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteActionPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteActionPermissionRule",
		Method:             "DELETE",
		PathPattern:        "/actions/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteActionPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteActionPermissionRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteActionPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeletePermissionsForAction deletes all permissions for an action with a given id

Deletes all permissions for an action with a given id
*/
func (a *Client) DeletePermissionsForAction(params *DeletePermissionsForActionParams, opts ...ClientOption) (*DeletePermissionsForActionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePermissionsForActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deletePermissionsForAction",
		Method:             "DELETE",
		PathPattern:        "/actions/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeletePermissionsForActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeletePermissionsForActionNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deletePermissionsForAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ExecuteActionByID runs an action with given id

Runs an action with given id
*/
func (a *Client) ExecuteActionByID(params *ExecuteActionByIDParams, opts ...ClientOption) (*ExecuteActionByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExecuteActionByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "executeActionById",
		Method:             "POST",
		PathPattern:        "/actions/{actionId}/executions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExecuteActionByIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExecuteActionByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for executeActionById: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ExecuteActionByName runs an action with given category and name

Runs an action with given category and name
*/
func (a *Client) ExecuteActionByName(params *ExecuteActionByNameParams, opts ...ClientOption) (*ExecuteActionByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExecuteActionByNameParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "executeActionByName",
		Method:             "POST",
		PathPattern:        "/actions/{categoryName}/{actionName}/executions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExecuteActionByNameReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExecuteActionByNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for executeActionByName: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ExportAction exports an action with given id

<p>Exports an action by its ID. If the request is successful, the action binary content is available as an attachment with MIME type application/zip (that is, a normal ZIP file) with a default file name {actionname}.action.</p><p>It is up to the client application to properly fetch and process this attachment, i.e. by saving it to the local file system.</p><p>The exported action has the same internal format as the actions exported by using the Orchestrator client.</p>
*/
func (a *Client) ExportAction(params *ExportActionParams, opts ...ClientOption) (*ExportActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "exportAction",
		Method:             "GET",
		PathPattern:        "/actions/{actionId}",
		ProducesMediaTypes: []string{"application/octet-stream", "application/zip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExportActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExportActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for exportAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetAction retrieves the definition of an action by category name and action name

The returned definition contains base data for the action, as well the input parameter's definitions and the output type.
*/
func (a *Client) GetAction(params *GetActionParams, opts ...ClientOption) (*GetActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAction",
		Method:             "GET",
		PathPattern:        "/actions/{categoryName}/{actionName}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetActionPermissionRule retrieves details for a specific permission rule

Each rule contains information about the principal and he access rights assigned.
*/
func (a *Client) GetActionPermissionRule(params *GetActionPermissionRuleParams, opts ...ClientOption) (*GetActionPermissionRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetActionPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getActionPermissionRule",
		Method:             "GET",
		PathPattern:        "/actions/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetActionPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetActionPermissionRuleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getActionPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPermissionsForAction retrieves action permissions

Retrieves action permissions
*/
func (a *Client) GetPermissionsForAction(params *GetPermissionsForActionParams, opts ...ClientOption) (*GetPermissionsForActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPermissionsForActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getPermissionsForAction",
		Method:             "GET",
		PathPattern:        "/actions/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPermissionsForActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPermissionsForActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPermissionsForAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportAction imports an action in the given category

<p>Imports an action in a given category. The action binary content should be available as multi-part content (see RFC-2387 for details).</p><p>Details of working with multi-part resources depend on the used client's HTTP/REST library. For example, in Spring it will look like:</p><pre>Sample client code:<br />-------------------<br />String url = "https://localhost:8281/vco/api/actions/";<br />MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();<br />Resource r = new FileSystemResource("D:/path/to/some.action");<br />parts.put("file", Arrays.asList(r));<br />parts.put("categoryName", "com.vmware.basic");<br />new RestTemplate().postForLocation(url, parts);<br />------------------- </pre>
*/
func (a *Client) ImportAction(params *ImportActionParams, opts ...ClientOption) (*ImportActionAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importAction",
		Method:             "POST",
		PathPattern:        "/actions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/octet-stream", "multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportActionAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
InsertPermissionsForAction sets permissions for an action with given id

Sets permissions for an action with given id
*/
func (a *Client) InsertPermissionsForAction(params *InsertPermissionsForActionParams, opts ...ClientOption) (*InsertPermissionsForActionOK, *InsertPermissionsForActionCreated, *InsertPermissionsForActionNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInsertPermissionsForActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "insertPermissionsForAction",
		Method:             "POST",
		PathPattern:        "/actions/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InsertPermissionsForActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, nil, err
	}
	switch value := result.(type) {
	case *InsertPermissionsForActionOK:
		return value, nil, nil, nil
	case *InsertPermissionsForActionCreated:
		return nil, value, nil, nil
	case *InsertPermissionsForActionNoContent:
		return nil, nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for actions_service: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListAllActions retrieves a list of all actions

Retrieves a list of all actions
*/
func (a *Client) ListAllActions(params *ListAllActionsParams, opts ...ClientOption) (*ListAllActionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListAllActionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listAllActions",
		Method:             "GET",
		PathPattern:        "/actions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListAllActionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListAllActionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listAllActions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateActionPermissionRule updates principal or access rights for a single permission rule with a given id

Updates principal or access rights for a single permission rule with a given id
*/
func (a *Client) UpdateActionPermissionRule(params *UpdateActionPermissionRuleParams, opts ...ClientOption) (*UpdateActionPermissionRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateActionPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateActionPermissionRule",
		Method:             "PUT",
		PathPattern:        "/actions/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateActionPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateActionPermissionRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateActionPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
