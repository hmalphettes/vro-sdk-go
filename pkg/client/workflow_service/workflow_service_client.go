// Code generated by go-swagger; DO NOT EDIT.

package workflow_service

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new workflow service API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for workflow service API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DeletePermissionsForWorkflow(params *DeletePermissionsForWorkflowParams, opts ...ClientOption) (*DeletePermissionsForWorkflowNoContent, error)

	DeleteWorkflow(params *DeleteWorkflowParams, opts ...ClientOption) (*DeleteWorkflowOK, error)

	DeleteWorkflowPermissionRule(params *DeleteWorkflowPermissionRuleParams, opts ...ClientOption) (*DeleteWorkflowPermissionRuleNoContent, error)

	DownloadWorkflowIcon(params *DownloadWorkflowIconParams, opts ...ClientOption) (*DownloadWorkflowIconOK, error)

	DownloadWorkflowSchema(params *DownloadWorkflowSchemaParams, opts ...ClientOption) (*DownloadWorkflowSchemaOK, error)

	DownloadWorkflowSchemaContent(params *DownloadWorkflowSchemaContentParams, opts ...ClientOption) (*DownloadWorkflowSchemaContentOK, error)

	GetAllTasksForWorkflow(params *GetAllTasksForWorkflowParams, opts ...ClientOption) (*GetAllTasksForWorkflowOK, *GetAllTasksForWorkflowNoContent, error)

	GetAllUserInteractionsForWorkflow(params *GetAllUserInteractionsForWorkflowParams, opts ...ClientOption) (*GetAllUserInteractionsForWorkflowOK, error)

	GetAllWorkflows(params *GetAllWorkflowsParams, opts ...ClientOption) (*GetAllWorkflowsOK, error)

	GetPermissionsForWorkflow(params *GetPermissionsForWorkflowParams, opts ...ClientOption) (*GetPermissionsForWorkflowOK, error)

	GetWorkflow(params *GetWorkflowParams, opts ...ClientOption) (*GetWorkflowOK, error)

	GetWorkflowPermissionRule(params *GetWorkflowPermissionRuleParams, opts ...ClientOption) (*GetWorkflowPermissionRuleOK, error)

	ImportWorkflow(params *ImportWorkflowParams, opts ...ClientOption) (*ImportWorkflowOK, error)

	InsertPermissionsForWorkflow(params *InsertPermissionsForWorkflowParams, opts ...ClientOption) (*InsertPermissionsForWorkflowOK, *InsertPermissionsForWorkflowCreated, error)

	UpdateWorkflowPermissionRule(params *UpdateWorkflowPermissionRuleParams, opts ...ClientOption) (*UpdateWorkflowPermissionRuleNoContent, error)

	Validate(params *ValidateParams, opts ...ClientOption) (*ValidateOK, error)

	ValidateExisting(params *ValidateExistingParams, opts ...ClientOption) (*ValidateExistingOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
DeletePermissionsForWorkflow deletes all permissions

Deletes all permissions for a workflow with a given ID.
*/
func (a *Client) DeletePermissionsForWorkflow(params *DeletePermissionsForWorkflowParams, opts ...ClientOption) (*DeletePermissionsForWorkflowNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePermissionsForWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deletePermissionsForWorkflow",
		Method:             "DELETE",
		PathPattern:        "/workflows/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeletePermissionsForWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeletePermissionsForWorkflowNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deletePermissionsForWorkflow: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteWorkflow deletes a workflow

Deletes a workflow with a given ID. If the workflow is referenced by some other workflows, or is running, it is considered to be 'in use' and the delete operation will fail, unless the 'force' option is provided.
*/
func (a *Client) DeleteWorkflow(params *DeleteWorkflowParams, opts ...ClientOption) (*DeleteWorkflowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteWorkflow",
		Method:             "DELETE",
		PathPattern:        "/workflows/{workflowId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteWorkflowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteWorkflow: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteWorkflowPermissionRule deletes permission rule

Deletes a single permission rule with a given ID.
*/
func (a *Client) DeleteWorkflowPermissionRule(params *DeleteWorkflowPermissionRuleParams, opts ...ClientOption) (*DeleteWorkflowPermissionRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteWorkflowPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteWorkflowPermissionRule",
		Method:             "DELETE",
		PathPattern:        "/workflows/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteWorkflowPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteWorkflowPermissionRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteWorkflowPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DownloadWorkflowIcon accesses workflow s icon

The icon's binary data is returned and response Content-type is set to correct media type, for example "Content-Type:image/png"
*/
func (a *Client) DownloadWorkflowIcon(params *DownloadWorkflowIconParams, opts ...ClientOption) (*DownloadWorkflowIconOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadWorkflowIconParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "downloadWorkflowIcon",
		Method:             "GET",
		PathPattern:        "/workflows/{id}/icon",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadWorkflowIconReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DownloadWorkflowIconOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for downloadWorkflowIcon: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DownloadWorkflowSchema accesses workflow s schema image

The icon's schema image binary data is returned and response Content-type is set to correct media type, for example "Content-Type:image/png"
*/
func (a *Client) DownloadWorkflowSchema(params *DownloadWorkflowSchemaParams, opts ...ClientOption) (*DownloadWorkflowSchemaOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadWorkflowSchemaParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "downloadWorkflowSchema",
		Method:             "GET",
		PathPattern:        "/workflows/{id}/schema",
		ProducesMediaTypes: []string{"image/png"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadWorkflowSchemaReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DownloadWorkflowSchemaOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for downloadWorkflowSchema: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DownloadWorkflowSchemaContent accesses workflow s schema

The schema data is returned and response Content-type is set to correct media type, for example "Content-Type:application/json"
*/
func (a *Client) DownloadWorkflowSchemaContent(params *DownloadWorkflowSchemaContentParams, opts ...ClientOption) (*DownloadWorkflowSchemaContentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadWorkflowSchemaContentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "downloadWorkflowSchemaContent",
		Method:             "GET",
		PathPattern:        "/workflows/{id}/content",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DownloadWorkflowSchemaContentReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DownloadWorkflowSchemaContentOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for downloadWorkflowSchemaContent: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetAllTasksForWorkflow retrieves all scheduled tasks for a requested workflow

Retrieves all scheduled tasks for a requested workflow.
*/
func (a *Client) GetAllTasksForWorkflow(params *GetAllTasksForWorkflowParams, opts ...ClientOption) (*GetAllTasksForWorkflowOK, *GetAllTasksForWorkflowNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllTasksForWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllTasksForWorkflow",
		Method:             "GET",
		PathPattern:        "/workflows/{workflowId}/tasks",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllTasksForWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetAllTasksForWorkflowOK:
		return value, nil, nil
	case *GetAllTasksForWorkflowNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for workflow_service: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetAllUserInteractionsForWorkflow retrieves all user interactions for a requested workflow

Retrieves all user interactions for a requested workflow.
*/
func (a *Client) GetAllUserInteractionsForWorkflow(params *GetAllUserInteractionsForWorkflowParams, opts ...ClientOption) (*GetAllUserInteractionsForWorkflowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllUserInteractionsForWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllUserInteractionsForWorkflow",
		Method:             "GET",
		PathPattern:        "/workflows/{workflowId}/interactions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllUserInteractionsForWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllUserInteractionsForWorkflowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllUserInteractionsForWorkflow: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetAllWorkflows gets all workflows

Get all workflows
*/
func (a *Client) GetAllWorkflows(params *GetAllWorkflowsParams, opts ...ClientOption) (*GetAllWorkflowsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllWorkflowsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllWorkflows",
		Method:             "GET",
		PathPattern:        "/workflows",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllWorkflowsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllWorkflowsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAllWorkflows: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetPermissionsForWorkflow retrieves workflow permissions

Retrieve workflow permissions.
*/
func (a *Client) GetPermissionsForWorkflow(params *GetPermissionsForWorkflowParams, opts ...ClientOption) (*GetPermissionsForWorkflowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPermissionsForWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getPermissionsForWorkflow",
		Method:             "GET",
		PathPattern:        "/workflows/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPermissionsForWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetPermissionsForWorkflowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getPermissionsForWorkflow: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetWorkflow retrieves the definition of a workflow

The returned definition contains base data for the workflow, as well the input and output parameter definitions. It also has links to the workflow presentation and workflow category in which this workflow is located.<p>To retrieve the input and output parameter definitions localized, add Accept-Language header, with the appropriate locale. In advance, localization resource should be present for the workflow, otherwise it defaults to the standard input and output parameter definitions.</p>
*/
func (a *Client) GetWorkflow(params *GetWorkflowParams, opts ...ClientOption) (*GetWorkflowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getWorkflow",
		Method:             "GET",
		PathPattern:        "/workflows/{id}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetWorkflowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getWorkflow: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetWorkflowPermissionRule retrieves permission rule

Each rule contains information about the principal and the access rights assigned.
*/
func (a *Client) GetWorkflowPermissionRule(params *GetWorkflowPermissionRuleParams, opts ...ClientOption) (*GetWorkflowPermissionRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetWorkflowPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getWorkflowPermissionRule",
		Method:             "GET",
		PathPattern:        "/workflows/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetWorkflowPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetWorkflowPermissionRuleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getWorkflowPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ImportWorkflow imports upload a workflow

Imports a workflow in a given category. The workflow binary content should be available as multi-part content (see RFC-2387 for details).<br />Details of working with multi-part resources depend on the used client HTTP/REST library. For example, in Spring it will look like:<br /><pre>Sample client code:-------------------String url = "https://localhost:8281/vco/api/workflows/";MultiValueMap<String, Resource> parts = new LinkedMultiValueMap<String, Resource>();Resource r = new FileSystemResource("D:/path/to/some.workflow");parts.put("file", Arrays.asList(r));parts.put("categoryId", "");new RestTemplate().postForLocation(url, parts); ------------------- </pre>
*/
func (a *Client) ImportWorkflow(params *ImportWorkflowParams, opts ...ClientOption) (*ImportWorkflowOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "importWorkflow",
		Method:             "POST",
		PathPattern:        "/workflows",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/octet-stream", "multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportWorkflowOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for importWorkflow: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
InsertPermissionsForWorkflow sets workflow permissions

Sets permissions for a workflow with a given ID.
*/
func (a *Client) InsertPermissionsForWorkflow(params *InsertPermissionsForWorkflowParams, opts ...ClientOption) (*InsertPermissionsForWorkflowOK, *InsertPermissionsForWorkflowCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInsertPermissionsForWorkflowParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "insertPermissionsForWorkflow",
		Method:             "POST",
		PathPattern:        "/workflows/{id}/permissions",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InsertPermissionsForWorkflowReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *InsertPermissionsForWorkflowOK:
		return value, nil, nil
	case *InsertPermissionsForWorkflowCreated:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for workflow_service: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateWorkflowPermissionRule updates permission rule

Updates principal or access rights for a single permission rule with a given ID.
*/
func (a *Client) UpdateWorkflowPermissionRule(params *UpdateWorkflowPermissionRuleParams, opts ...ClientOption) (*UpdateWorkflowPermissionRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateWorkflowPermissionRuleParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateWorkflowPermissionRule",
		Method:             "PUT",
		PathPattern:        "/workflows/{id}/permissions/{ruleId}",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateWorkflowPermissionRuleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateWorkflowPermissionRuleNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateWorkflowPermissionRule: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
Validate validates workflow content

Validate provided workflow content
*/
func (a *Client) Validate(params *ValidateParams, opts ...ClientOption) (*ValidateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "validate",
		Method:             "PUT",
		PathPattern:        "/workflows/validate/schema",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ValidateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for validate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ValidateExisting validates existing workflow

Validate existing workflow by workflow id
*/
func (a *Client) ValidateExisting(params *ValidateExistingParams, opts ...ClientOption) (*ValidateExistingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateExistingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "validateExisting",
		Method:             "GET",
		PathPattern:        "/workflows/{workflowId}/validate",
		ProducesMediaTypes: []string{"application/json", "application/xml"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateExistingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ValidateExistingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for validateExisting: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
